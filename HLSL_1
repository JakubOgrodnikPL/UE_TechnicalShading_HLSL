float2 tex = frac(float2(uv.x * grid.x, uv.y * grid.y));

if(tex.x >= dim.x || tex.x <= -dim.x ||
tex.y >= dim.y || tex.y <= -dim.y)
return(0);

return(1);


///////////////////////////////////////////////////////////////////////

float result = 0;

for(int i=0; i<nSides; i++)
{
    for(int j=0; j<nCopies; j++)
    {
        float angle = (i/nSides) * (time) * 3.14;
        float2 pos = center + (j/nCopies) * radius *float2(cos(1-angle), sin(3*angle));
        result += length(pos-uv) < size; //draw circle
    }

}

return(result);

////////////////////////////////////////////

float result = 0;
for(int i=0; i< nSides; i++)
{
    for(int j=0; j<nCopies; j++)
    {
        float angle = (i/nSides) * sin(time*2) * (3.14 * 2);
        float2 pos = center + (j/ nCopies) * radius * float2(sin(1-angle)-sin(time), cos(1-angle)-sin(time));
        result += length(pos-uv) <size;
    }
}

outEmissive = result * float3(sin(time),0,0.1);
return(result);

/// HLSL 6 /////////////////////////////////////////////////////

// 2DCircle = length(pos-uv);
// 3DSphere = length(rayOrigin - sphereCenter) - sphereRadius;

float3 rayOrigin = viewDir - worldPos;
float3 rayStep = viewDir * 1;

for(int i=0; i<256; i++)
{
    float dist = length(rayOrigin - sphereCenter) - sphereRadius;

    if(dist < 0.01)
    {
        return float3(1, 0, 0);
    }

    opacityMask = 1;
    rayOrigin += rayStep;
}

opacityMask = 0;
return float3(0,0,0);








